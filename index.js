// Generated by CoffeeScript 1.7.1
var assert, assets, bodyParser, compress, cookieParser, errorHandler, express, favicon, logger, static_view, url, webapp_view;

express = require('express');

favicon = require('serve-favicon');

compress = require('compression');

bodyParser = require('body-parser');

cookieParser = require('cookie-parser');

errorHandler = require('errorhandler');

logger = require('morgan');

assets = require('connect-assets');

webapp_view = require('express-webapp-view');

static_view = require('express-static-view');

url = require('url');

assert = require('assert');

exports.connect = function(options) {
  var Recore, app, model, name, _fn, _ref;
  Recore = options.recore;
  assert(Recore, "recore instance required");
  app = express();
  app.locals.title = "Recore Backend";
  app.locals.subtitle = options.title;
  app.locals.count = {};
  app.locals.models = [];
  _ref = Recore.getModels();
  _fn = function(name, model) {
    app.locals.models.push(name);
    return model.count(function(err, count) {
      if (err) {
        return;
      }
      return app.locals.count[name] = count;
    });
  };
  for (name in _ref) {
    model = _ref[name];
    _fn(name, model);
  }
  app.set('view engine', 'jade');
  app.set('views', "" + __dirname + "/views");
  app.use(favicon("" + __dirname + "/public/images/favicon.png"));
  app.use(compress());
  app.use(express["static"]("" + __dirname + "/public"));
  app.use(bodyParser.json());
  app.use(bodyParser.urlencoded());
  app.use(cookieParser());
  app.use(Recore.connect({
    url: "/validator.js",
    namespace: 'validator'
  }));
  app.use(logger("dev"));
  app.get("/stats", function(req, res) {
    var nodes, random_client, random_index, random_server, redism, server_list, servers, stats;
    stats = [];
    redism = Recore.getClient();
    nodes = redism.client_list.length;
    server_list = Object.keys(redism.server_list);
    servers = server_list.length;
    stats.push({
      name: 'Nodes',
      group: '2',
      content: {
        nodes: nodes,
        servers: servers
      }
    });
    random_index = Math.floor(Math.random() * (servers - 1));
    random_server = server_list[random_index];
    random_client = redism.clients[random_server];
    return random_client.info(function(err, raw) {
      var info, key, keys, row, rows, serverparts, value, _i, _info, _len, _ref1;
      if (err) {
        return res.status(500);
      }
      serverparts = url.parse(random_server);
      keys = 0;
      info = {};
      _info = {};
      rows = raw.match(/(\w+):(.*)/g);
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        _ref1 = row.split(":"), key = _ref1[0], value = _ref1[1];
        if (key.match(/db(\d+)/)) {
          keys += parseInt(value.split(',')[0].split("=")[1]);
        }
        _info[key] = value;
      }
      info['Keys'] = keys;
      info['Memory Used'] = _info['used_memory_human'];
      info['Memory Peak'] = _info['used_memory_peak_human'];
      info['Connections'] = _info['connected_clients'];
      info['Uptime'] = "" + _info['uptime_in_days'] + " days";
      info['AOF Status'] = _info['aof_last_write_status'];
      info['RDB Status'] = _info['rdb_last_bgsave_status'];
      info['Redis Version'] = _info['redis_version'];
      stats.push({
        name: "Info of " + serverparts.host,
        group: '2',
        content: info
      });
      return random_client.slowlog('get', 10, function(err, slowlogs) {
        var log, logs, _j, _len1;
        if (err) {
          return res.send(500);
        }
        logs = [];
        for (_j = 0, _len1 = slowlogs.length; _j < _len1; _j++) {
          log = slowlogs[_j];
          logs.push({
            date: new Date(log[1] * 1000).toISOString(),
            time: "" + (log[2] / 1000) + "ms",
            command: log[3].join(" ")
          });
        }
        stats.push({
          name: "Slowlogs from " + serverparts.host,
          size: 2,
          group: 1,
          content: logs
        });
        return res.send(stats);
      });
    });
  });
  app.get("/stats/:node", function(req, res) {
    return res.send([]);
  });
  app.get("/schema/:model", function(req, res) {
    var def, default_value, id_generator, ins, properties, score, sortables, type, _id_generator, _ref1, _ref2, _sortables;
    if (!req.params.model) {
      return res.status(404);
    }
    properties = {};
    model = Recore.getModel(req.params.model);
    ins = new model;
    sortables = [];
    _sortables = [];
    _ref1 = ins.properties;
    for (name in _ref1) {
      def = _ref1[name];
      score = 0;
      type = "";
      default_value = "";
      if (typeof def.defaultValue === "function") {
        default_value = def.defaultValue.toString();
        def.defaultValue = "[Function]";
      }
      if (typeof def.type === 'function') {
        type = def.type.toString();
        def.type = "[Function]";
      }
      if (def.__numericIndex) {
        score = 10;
        if (def.type === 'timestamp') {
          score += 100;
          if (typeof def.defaultValue === 'function') {
            score += 300;
          }
        }
        _sortables[score] = name;
      }
      properties[name] = {
        type: (_ref2 = def.type) != null ? _ref2 : "string",
        _type: type,
        index: def.index,
        unique: def.unique,
        default_value: def.defaultValue,
        _default_value: default_value,
        numeric_index: def.__numericIndex
      };
    }
    if (typeof ins.idGenerator === 'function') {
      id_generator = '[Function]';
      _id_generator = ins.idGenerator.toString();
    } else {
      id_generator = ins.idGenerator;
    }
    _sortables.map(function(name) {
      return sortables.push(name);
    });
    return model.count(function(err, count) {
      if (err) {
        return res.status(500);
      }
      return res.send({
        name: req.params.model,
        count: count,
        id_generator: id_generator,
        _id_generator: _id_generator != null ? _id_generator : "",
        sortables: sortables,
        properties: properties
      });
    });
  });
  app.get("/record/:model/page/:page", function(req, res) {
    var count, direction, field, page, per_page, records, start, step, stop;
    if (!req.params.model) {
      return res.status(404);
    }
    step = 10;
    page = req.params.page || 1;
    per_page = Math.min(req.query.per_page || 30, 100);
    direction = req.query.direction || 'DESC';
    direction = direction.toUpperCase();
    field = req.query.sort_on || 'id';
    model = Recore.getModel(req.params.model);
    start = (page - 1) * per_page + 1;
    stop = start + per_page - 1;
    count = 0;
    records = [];
    return model.getClient().scard(model.getIdsetsKey(), function(err, total) {
      var offset;
      if (err) {
        return res.status(500);
      }
      if (total == null) {
        total = 0;
      }
      total = parseInt(total);
      if (total === 0) {
        return res.send(records);
      }
      stop = Math.min(total, stop);
      if (field !== 'id') {
        return model.sort({
          field: field,
          direction: direction,
          limit: [(page - 1) * per_page, per_page]
        }, function(err, ids) {
          if (err) {
            return res.status(500);
          }
          return ids.forEach(function(id) {
            return (function(id) {
              return model.load(id, function(err, props) {
                count++;
                if (!props) {
                  return;
                }
                records.push({
                  id: this.id,
                  model: model.modelName,
                  total: total,
                  range: [start, stop],
                  properties: props
                });
                if (count === per_page) {
                  return res.send(records);
                }
              });
            })(id);
          });
        });
      }
      offset = (page - 1) * per_page;
      return model.getClient().sort(model.getIdsetsKey(), "limit", offset, per_page, direction, function(err, ids) {
        var fetch, idx, max;
        if (err) {
          return res.status(500);
        }
        if (ids.length === 0) {
          return res.send(records);
        }
        idx = 0;
        max = ids.length;
        fetch = function() {
          var id;
          id = ids[idx];
          return model.load(id, function(err, props) {
            if (err && err !== 'not found') {
              return res.status(500);
            }
            if (props) {
              records.push({
                id: this.id,
                model: model.modelName,
                total: total,
                range: [start, stop],
                properties: props
              });
            }
            if (idx + 1 === max) {
              return res.send(records);
            }
            idx++;
            return fetch();
          });
        };
        return fetch();
      });
    });
  });
  app.put("/record", function(req, res) {
    return console.log(req.body);
  });
  app.get("/", static_view('layout'));
  app.use(errorHandler());
  app.on('mount', function(parent) {
    app.locals.base_uri = app.path();
    app.use(assets({
      src: "" + __dirname + "/public",
      helperContext: app.locals,
      servePath: app.path()
    }));
    return app.use("/templates", webapp_view.connect({
      apps: 'app',
      webroot: "" + __dirname + "/public/javascripts",
      context: app.locals
    }));
  });
  return app;
};
